import { tmpName } from 'tmp-promise';
import { DenoBridge } from '../bridge.js';
import { getFunctionConfig } from '../config.js';
import { generateStage2 } from '../formats/javascript.js';
import { ImportMap } from '../import_map.js';
import { getLogger } from '../logger.js';
import { ensureLatestTypes } from '../types.js';
import { killProcess, waitForServer } from './util.js';
const prepareServer = ({ bootstrapURL, deno, distDirectory, flags: denoFlags, formatExportTypeError, formatImportError, importMap, logger, port, }) => {
    const processRef = {};
    const startServer = async (functions, env = {}, options = {}) => {
        if ((processRef === null || processRef === void 0 ? void 0 : processRef.ps) !== undefined) {
            await killProcess(processRef.ps);
        }
        let graph;
        const stage2Path = await generateStage2({
            bootstrapURL,
            distDirectory,
            fileName: 'dev.js',
            functions,
            formatExportTypeError,
            formatImportError,
        });
        try {
            // This command will print a JSON object with all the modules found in
            // the `stage2Path` file as well as all of their dependencies.
            // Consumers such as the CLI can use this information to watch all the
            // relevant files and issue an isolate restart when one of them changes.
            const { stdout } = await deno.run(['info', '--json', stage2Path]);
            graph = JSON.parse(stdout);
        }
        catch {
            // no-op
        }
        const bootstrapFlags = ['--port', port.toString()];
        // We set `extendEnv: false` to avoid polluting the edge function context
        // with variables from the user's system, since those will not be available
        // in the production environment.
        await deno.runInBackground(['run', ...denoFlags, stage2Path, ...bootstrapFlags], processRef, {
            pipeOutput: true,
            env,
            extendEnv: false,
        });
        let functionsConfig = [];
        if (options.getFunctionsConfig) {
            functionsConfig = await Promise.all(functions.map((func) => getFunctionConfig({ func, importMap, deno, bootstrapURL, log: logger })));
        }
        const success = await waitForServer(port, processRef.ps);
        return {
            functionsConfig,
            graph,
            success,
        };
    };
    return startServer;
};
const serve = async ({ bootstrapURL, certificatePath, debug, distImportMapPath, inspectSettings, formatExportTypeError, formatImportError, importMapPaths = [], onAfterDownload, onBeforeDownload, port, systemLogger, }) => {
    const logger = getLogger(systemLogger, debug);
    const deno = new DenoBridge({
        debug,
        logger,
        onAfterDownload,
        onBeforeDownload,
    });
    // We need to generate a stage 2 file and write it somewhere. We use a
    // temporary directory for that.
    const distDirectory = await tmpName();
    // Wait for the binary to be downloaded if needed.
    await deno.getBinaryPath();
    // Downloading latest types if needed.
    await ensureLatestTypes(deno, logger);
    const importMap = new ImportMap();
    await importMap.addFiles(importMapPaths, logger);
    const flags = ['--allow-all', `--import-map=${importMap.toDataURL()}`, '--no-config'];
    if (certificatePath) {
        flags.push(`--cert=${certificatePath}`);
    }
    if (debug) {
        flags.push('--log-level=debug');
    }
    else {
        flags.push('--quiet');
    }
    if (inspectSettings && inspectSettings.enabled) {
        if (inspectSettings.pause) {
            flags.push(inspectSettings.address ? `--inspect-brk=${inspectSettings.address}` : '--inspect-brk');
        }
        else {
            flags.push(inspectSettings.address ? `--inspect=${inspectSettings.address}` : '--inspect');
        }
    }
    const server = prepareServer({
        bootstrapURL,
        deno,
        distDirectory,
        flags,
        formatExportTypeError,
        formatImportError,
        importMap,
        logger,
        port,
    });
    if (distImportMapPath) {
        await importMap.writeToFile(distImportMapPath);
    }
    return server;
};
export { serve };
