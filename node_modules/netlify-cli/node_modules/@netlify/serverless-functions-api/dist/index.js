// src/index.ts
import { fileURLToPath } from "url";

// src/api.ts
import { pipeline as pipelineCb, Readable } from "node:stream";
import { promisify } from "node:util";

// src/account.ts
var getAccountId = (idHeader) => idHeader ?? "";

// src/geo.ts
import { Buffer } from "node:buffer";
var parseGeoHeader = (geoHeader) => {
  if (geoHeader === null) {
    return {};
  }
  try {
    const geoData = JSON.parse(Buffer.from(geoHeader, "base64").toString("utf-8"));
    return geoData;
  } catch {
    return {};
  }
};

// src/headers.ts
var NFClientConnectionIP = "x-nf-client-connection-ip";
var NFGeo = "x-nf-geo";
var NFAccountID = "x-nf-account-id";
var NFRequestID = "x-nf-request-id";
var fromEventHeaders = (eventHeaders) => {
  const headers = new Headers();
  Object.entries(eventHeaders).forEach(([name, value]) => {
    if (value !== void 0) {
      headers.set(name.toLowerCase(), value);
    }
  });
  return headers;
};
var toObject = (headers) => {
  const headersObj = {};
  for (const [name, value] of headers.entries()) {
    headersObj[name] = value;
  }
  return headersObj;
};

// src/ip.ts
var getIP = (ipHeader) => ipHeader ?? "";

// src/request_id.ts
var getRequestId = (requestIdHeader) => requestIdHeader ?? "";

// src/server.ts
import { env } from "process";
var getServerObject = () => {
  const server = {
    region: env.AWS_REGION
  };
  delete env.AWS_REGION;
  return server;
};

// src/site.ts
import { env as env2 } from "process";
var getSiteObject = () => {
  const site = {
    id: env2.SITE_ID,
    name: env2.SITE_NAME,
    url: env2.URL
  };
  delete env2.SITE_ID;
  delete env2.SITE_NAME;
  delete env2.URL;
  return site;
};

// src/context.ts
var json = (input) => {
  const data = JSON.stringify(input);
  return new Response(data, {
    headers: {
      "content-type": "application/json"
    }
  });
};
var getContext = (req, cookies) => {
  const context = {
    account: {
      id: getAccountId(req.headers.get(NFAccountID))
    },
    cookies: cookies.getPublicInterface(),
    geo: parseGeoHeader(req.headers.get(NFGeo)),
    ip: getIP(req.headers.get(NFClientConnectionIP)),
    json,
    log: console.log,
    next: () => {
      throw new Error("`context.next` is not implemented for serverless functions");
    },
    requestId: getRequestId(req.headers.get(NFRequestID)),
    rewrite: (input) => {
      const url = makeURL(input, req.url);
      return rewrite(url);
    },
    server: getServerObject(),
    site: getSiteObject()
  };
  return context;
};
var makeURL = (input, baseURL) => {
  if (input instanceof URL) {
    return input;
  }
  if (input.startsWith("/")) {
    const url = new URL(baseURL);
    url.pathname = input;
    return url;
  }
  return new URL(input);
};
var rewrite = async (url) => {
  const res = await fetch(url);
  return res;
};

// node_modules/@netlify/node-cookies/dist/http/cookies.js
import assert from "node:assert";

// node_modules/@netlify/node-cookies/dist/datetime/to_imf.js
function toIMF(date) {
  function dtPad(v, lPad = 2) {
    return v.padStart(lPad, "0");
  }
  const d = dtPad(date.getUTCDate().toString());
  const h = dtPad(date.getUTCHours().toString());
  const min = dtPad(date.getUTCMinutes().toString());
  const s = dtPad(date.getUTCSeconds().toString());
  const y = date.getUTCFullYear();
  const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  return `${days[date.getUTCDay()]}, ${d} ${months[date.getUTCMonth()]} ${y} ${h}:${min}:${s} GMT`;
}

// node_modules/@netlify/node-cookies/dist/http/cookies.js
var FIELD_CONTENT_REGEXP = /^(?=[\u0020-\u007E]*$)[^()@<>,;:\\"[\]?={}\s]+$/;
function toString(cookie) {
  if (!cookie.name) {
    return "";
  }
  const out = [];
  validateName(cookie.name);
  validateValue(cookie.name, cookie.value);
  out.push(`${cookie.name}=${cookie.value}`);
  if (cookie.name.startsWith("__Secure")) {
    cookie.secure = true;
  }
  if (cookie.name.startsWith("__Host")) {
    cookie.path = "/";
    cookie.secure = true;
    delete cookie.domain;
  }
  if (cookie.secure) {
    out.push("Secure");
  }
  if (cookie.httpOnly) {
    out.push("HttpOnly");
  }
  if (typeof cookie.maxAge === "number" && Number.isInteger(cookie.maxAge)) {
    assert(cookie.maxAge >= 0, "Max-Age must be an integer superior or equal to 0");
    out.push(`Max-Age=${cookie.maxAge}`);
  }
  if (cookie.domain) {
    validateDomain(cookie.domain);
    out.push(`Domain=${cookie.domain}`);
  }
  if (cookie.sameSite) {
    out.push(`SameSite=${cookie.sameSite}`);
  }
  if (cookie.path) {
    validatePath(cookie.path);
    out.push(`Path=${cookie.path}`);
  }
  if (cookie.expires) {
    const { expires } = cookie;
    const dateString = toIMF(typeof expires === "number" ? new Date(expires) : expires);
    out.push(`Expires=${dateString}`);
  }
  if (cookie.unparsed) {
    out.push(cookie.unparsed.join("; "));
  }
  return out.join("; ");
}
function validateName(name) {
  if (name && !FIELD_CONTENT_REGEXP.test(name)) {
    throw new TypeError(`Invalid cookie name: "${name}".`);
  }
}
function validatePath(path) {
  if (path == null) {
    return;
  }
  for (let i = 0; i < path.length; i++) {
    const c = path.charAt(i);
    if (c < String.fromCharCode(32) || c > String.fromCharCode(126) || c == ";") {
      throw new Error(`${path}: Invalid cookie path char '${c}'`);
    }
  }
}
function validateValue(name, value) {
  if (value == null || name == null)
    return;
  for (let i = 0; i < value.length; i++) {
    const c = value.charAt(i);
    if (c < String.fromCharCode(33) || c == String.fromCharCode(34) || c == String.fromCharCode(44) || c == String.fromCharCode(59) || c == String.fromCharCode(92) || c == String.fromCharCode(127)) {
      throw new Error(`RFC2616 cookie '${name}' cannot contain character '${c}'`);
    }
    if (c > String.fromCharCode(128)) {
      throw new Error(`RFC2616 cookie '${name}' can only have US-ASCII chars as value${c.charCodeAt(0).toString(16)}`);
    }
  }
}
function validateDomain(domain) {
  if (domain == null) {
    return;
  }
  const char1 = domain.charAt(0);
  const charN = domain.charAt(domain.length - 1);
  if (char1 == "-" || charN == "." || charN == "-") {
    throw new Error(`Invalid first/last char in cookie domain: ${domain}`);
  }
}
function getCookies(headers) {
  const cookie = headers.get("Cookie");
  if (cookie != null) {
    const out = {};
    const c = cookie.split(";");
    for (const kv of c) {
      const [cookieKey, ...cookieVal] = kv.split("=");
      assert(cookieKey != null);
      const key = cookieKey.trim();
      out[key] = cookieVal.join("=");
    }
    return out;
  }
  return {};
}
function setCookie(headers, cookie) {
  const v = toString(cookie);
  if (v) {
    headers.append("Set-Cookie", v);
  }
}
function deleteCookie(headers, name, attributes) {
  setCookie(headers, Object.assign({ name, value: "", expires: /* @__PURE__ */ new Date(0) }, attributes));
}

// src/cookie_store.ts
var CookieStore = class {
  constructor(request) {
    this.ops = [];
    this.request = request;
  }
  apply(response) {
    this.ops.forEach((op) => {
      switch (op.type) {
        case "delete":
          deleteCookie(response.headers, op.options.name, {
            domain: op.options.domain,
            path: op.options.path
          });
          break;
        case "set":
          setCookie(response.headers, op.cookie);
          break;
        default:
      }
    });
  }
  delete(input) {
    const defaultOptions = {
      path: "/"
    };
    const options = typeof input === "string" ? { name: input } : input;
    this.ops.push({
      options: { ...defaultOptions, ...options },
      type: "delete"
    });
  }
  get(name) {
    return getCookies(this.request.headers)[name];
  }
  getPublicInterface() {
    return {
      delete: this.delete.bind(this),
      get: this.get.bind(this),
      set: this.set.bind(this)
    };
  }
  set(cookie) {
    this.ops.push({ cookie, type: "set" });
  }
};

// src/request.ts
import { Buffer as Buffer2 } from "buffer";
var buildRequestBody = (body, isBase64Encoded) => {
  if (body === null || body === void 0 || body === "") {
    return;
  }
  if (isBase64Encoded) {
    return Buffer2.from(body, "base64");
  }
  return body;
};

// src/api.ts
var pipeline = promisify(pipelineCb);
var getLambdaHandler = (func) => awslambda.streamifyResponse(async (event, responseStream) => {
  const { body: rawBody, httpMethod: method, isBase64Encoded, headers: headersObject, rawUrl } = event;
  const headers = fromEventHeaders(headersObject);
  const body = buildRequestBody(rawBody, isBase64Encoded);
  const req = new Request(rawUrl, {
    body,
    headers,
    method
  });
  const cookies = new CookieStore(req);
  const context = getContext(req, cookies);
  const res = await func.default(req, context);
  if (res instanceof Response) {
    cookies.apply(res);
    const responseMetadata = {
      headers: toObject(res.headers),
      statusCode: res.status
    };
    const responseBody = awslambda.HttpResponseStream.from(responseStream, responseMetadata);
    if (res.body === null) {
      responseBody.end();
      return;
    }
    const stream = Readable.fromWeb(res.body);
    await pipeline(stream, responseBody);
    return;
  }
  if (res === void 0) {
    const responseBody = awslambda.HttpResponseStream.from(responseStream, { statusCode: 204 });
    responseBody.end();
    return;
  }
  throw new Error(`Function returned an unsupported value. Accepted types are 'Response' or 'undefined'`);
});

// src/index.ts
var getPath = () => fileURLToPath(import.meta.url);
export {
  getLambdaHandler,
  getPath
};
